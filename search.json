[
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html",
    "title": "Linux, Commandline, and Scripting",
    "section": "",
    "text": "The following notes assume that you are all set up to use your accounts on the CLASSE Linux systems.\n\nYou know how to use ssh to access lnx201; or\nYou know how to launch a terminal from CLASSE JupyterLab instance.\n\nDepending on your level of familiarity with the system, you might know enough commands to find your way around.\nBut it probably is not a good idea to assume that you know your way around, so let us see what you might need to know to in order to become a proficient user of the systems.\n\n\n\n\n\nSuppose you want to find all the text files in a directory that contain a certain pattern, like “hello”. How would you do that?\nNow suppose you want to replace all instances of “hello” with “bonjour”. How would you do that?\nYou can do these things using the Linux command line. You would be invoking commands like find and grep and sed and awk, instead of using programs with a graphical user interfaces.\nPlenty of software with friendly user interfaces exist, and they are often easier to use. In order to use the command line, you will have to be familiar with often arcane tools and memorize stuff.\nWhy would you want to use the command line then?\nBecause, for certain types of tasks, it is often quick and efficient to use the command line. You can “chain” or compose separate programs that do different things together. You can also save fairly complicated tasks in the form of scripts for later use, and share them with your colleagues.\nLearning to use the command line well will leave more power on your hands."
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#some-words-about-command-line",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#some-words-about-command-line",
    "title": "Linux, Commandline, and Scripting",
    "section": "",
    "text": "Suppose you want to find all the text files in a directory that contain a certain pattern, like “hello”. How would you do that?\nNow suppose you want to replace all instances of “hello” with “bonjour”. How would you do that?\nYou can do these things using the Linux command line. You would be invoking commands like find and grep and sed and awk, instead of using programs with a graphical user interfaces.\nPlenty of software with friendly user interfaces exist, and they are often easier to use. In order to use the command line, you will have to be familiar with often arcane tools and memorize stuff.\nWhy would you want to use the command line then?\nBecause, for certain types of tasks, it is often quick and efficient to use the command line. You can “chain” or compose separate programs that do different things together. You can also save fairly complicated tasks in the form of scripts for later use, and share them with your colleagues.\nLearning to use the command line well will leave more power on your hands."
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#shell-history",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#shell-history",
    "title": "Linux, Commandline, and Scripting",
    "section": "Shell history",
    "text": "Shell history\n\nup/down keys\nhistory\nControl + R"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#command-completion",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#command-completion",
    "title": "Linux, Commandline, and Scripting",
    "section": "Command completion",
    "text": "Command completion\n\n\nUsing the tab key"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#exiting-a-shell",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#exiting-a-shell",
    "title": "Linux, Commandline, and Scripting",
    "section": "Exiting a shell",
    "text": "Exiting a shell\n\nexit\nControl + D"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#how-bash-sets-up-the-environment",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#how-bash-sets-up-the-environment",
    "title": "Linux, Commandline, and Scripting",
    "section": "How bash sets up the environment",
    "text": "How bash sets up the environment\n\nlogin shells, non-login shells\n/etc/profile, ~/.bash_profile\n/etc/bashrc, ~/.bashrc"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#changing-environment-variables",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#changing-environment-variables",
    "title": "Linux, Commandline, and Scripting",
    "section": "Changing environment variables",
    "text": "Changing environment variables\n\nexport command\necho $HOME command"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#directory-structure",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#directory-structure",
    "title": "Linux, Commandline, and Scripting",
    "section": "Directory structure",
    "text": "Directory structure\nThe first, or top-level directory of this tree is a special directory, called the “root directory”, or /. All other directories are under the root directory. You can list things under / with the command ls /:\n[user@lnx201 ~]$ ls /\nbin   cdat  cvmfs  etc   lib    media  mnt  nfs   opt   root  sbin  sys  usr\nboot  cifs  dev    home  lib64  misc   net  null  proc  run   srv   tmp  var\nIt is useful to know about some of these directories:\n\nhome is where user home directories are.\n\nroot is the home directory for root user, aka superuser.\n\nbin and sbib are for programs.\nlib and lib64 are for libraries.\netc is for configuration files.\ntmp is for temporary files\nproc provides an interface with processes."
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#absolute-and-relative-paths",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#absolute-and-relative-paths",
    "title": "Linux, Commandline, and Scripting",
    "section": "Absolute and relative paths",
    "text": "Absolute and relative paths"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#wildcard-operator",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#wildcard-operator",
    "title": "Linux, Commandline, and Scripting",
    "section": "Wildcard operator",
    "text": "Wildcard operator\n\n\n*\nuse * carefully with rm"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#the-current-working-directory",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#the-current-working-directory",
    "title": "Linux, Commandline, and Scripting",
    "section": "The current working directory",
    "text": "The current working directory\nAt any time in the shell, we are “inside” a single directory, known as the current working directory. When you list files with ls, a list of files and directories of the current working directory will be printed on the output.\nWhen you log in to lnx201, initially you will be in a directory named /home/${USER}, where ${USER} is your username on lnx201. This is what is known as your /home directory/. When you log in first, your home directory will be your current working directory.\nTo find where you are, use the command pwd.\nThe below commands are useful:\n\nmkdir test will create a directory named test\ncd test will change the working directory to test.\nls will list files and directories in the current working directory.\nrm will remove a file.\nrm &lt;name of directory&gt; will not remove a directory; you have to remove it recursively, like so: rm -r &lt;name of directory&gt;.\n\ncd - is useful: it will switch you to the directory that you were previously in.\n. and .. are special directory names: . means the current directory, and .. means its parent directory, or the directory above it in the directory hierarchy.\ntouch command is used to change file timestamps. You can also use touch to create an empty file, like so: touch test.txt.\n\nTODO: directory navigation: ls, cd, mkdir, rm, ln, pwd, touch"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#users-and-groups",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#users-and-groups",
    "title": "Linux, Commandline, and Scripting",
    "section": "Users and groups",
    "text": "Users and groups\nLinux is a multi-user operating system. Since many people can be using the system, there needs to be mechanisms in place to ensure separation between them, while ensuring that they can access shared resources when necessary.\nThe basic mechanism is the concept of users and groups.\nThe root user is a special user that has all the permissions. They can change most things about the system. The root user can change system configuration, add and remove users and groups, etc.\nMost of the time, we do not need neither the power nor the responsibilities of the root user. So we have a non-root, regular user account in lnx201.\nYour account also belongs to certain groups. Groups are the way to grant permission to a group of accounts. You can find the groups you belong to using groups command:\n[ssasidharan@lnx201 ~]$ groups\nchess classeuser\n[ssasidharan@lnx201 ~]$\nUsers and groups have distinct numerical identifiers too. You can find them with id command:\n[ssasidharan@lnx201 ~]$ id\nuid=63499(ssasidharan) gid=262(chess) groups=262(chess),750(classeuser)\nIf you run ls -l (-l is for long listing format) command to list files and folders in your home directory, the result will be something like this:\n[ssasidharan@lnx201 ~]$ ls -l\ntotal 4\ndrwxr-xr-x 2 ssasidharan chess   28 Mar 28 09:36 bin\ndrwxr-xr-x 2 ssasidharan chess  144 Mar 12 00:27 CLASSE_shortcuts\ndrwxr-xr-x 2 ssasidharan chess   30 Mar 26 15:22 Desktop\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Documents\nlrwxrwxrwx 1 ssasidharan chess   31 Mar 26 15:21 Downloads -&gt; /cdat/tem/ssasidharan/Downloads\n-rw-r--r-- 1 ssasidharan chess 3254 Mar  7 15:55 helloworld.ipynb\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Music\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Pictures\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Public\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Templates\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Videos\nLet us see what the above columns means:\n\nThe first column lists permissions on the file/folder. (We will see what this means in the next section.)\nThe second column shows number of links to it.\nThe third one shows the user who owns it.\nThe fourth one shows the group that owns the file.\nThe fifth one is the size of the file in bytes. Note that directories are a little special here – what you see here is not the total size of all the files and folders under the directory, but the space the directory itself uses on disk.\nThe next column (the whole Mar 26 15:21 segment) shows a timestamp when the file/folder was last modified.\nFinally, the name of the file/folder. Note that Downloads -&gt;   /cdat/tem/ssasidharan/Downloads is a bit special: it means that Downloads folder is in fact a link to /cdat/tem/ssasidharan/Downloads."
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#permissions-and-ownership",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#permissions-and-ownership",
    "title": "Linux, Commandline, and Scripting",
    "section": "Permissions and ownership",
    "text": "Permissions and ownership\nLet us see what a string like drwxr-xr-x from the above example means. This string, sometimes called “permission bits” or “file mode bits”, is ten characters long. Each of the characters are shorthand signifying something.\n\nThe first d stands for directory. (For files, this will be a -.)\nThe next three rwx are for user’s permissions.\nThe next three r-x are for group permissions.\nThe final three r-x are for permissions for the rest of the users.\n\nNow, what do those r and w and x mean?\n\nr means permission to read.\nw means permission to write.\nx means permission to execute, in the case of files. In the case of directories, x means that you can cd into them.\n\n\nChanging permissions with chmod\nYou can use chmod command to change permissions. If you create a shell script named test.sh, for example, it won’t be executable by default. You will have to change the file mode bits using chmod:\n[ssasidharan@lnx201 ~]$ ls -l test.sh\n-rw-r--r-- 1 ssasidharan chess 0 Mar 28 13:39 test.sh\n[ssasidharan@lnx201 ~]$ ./test.sh\n-bash: ./test.sh: Permission denied\n[ssasidharan@lnx201 ~]$ chmod +x test.sh\n[ssasidharan@lnx201 ~]$ ls -l test.sh\n-rwxr-xr-x 1 ssasidharan chess 0 Mar 28 13:39 test.sh\n[ssasidharan@lnx201 ~]$ ./test.sh\nYou can remove the x bit like so:\n[ssasidharan@lnx201 ~]$ chmod -x test.sh\n[ssasidharan@lnx201 ~]$ ls -l test.sh\n-rw-r--r-- 1 ssasidharan chess 0 Mar 28 13:39 test.sh\nYou can also grant permission to just the owner, or group, or others:\n[ssasidharan@lnx201 ~]$ chmod u+x test.sh\n[ssasidharan@lnx201 ~]$ ls -l test.sh\n-rwxr--r-- 1 ssasidharan chess 0 Mar 28 13:39 test.sh\n[ssasidharan@lnx201 ~]$ chmod g+x test.sh\n[ssasidharan@lnx201 ~]$ ls -l test.sh\n-rwxr-xr-- 1 ssasidharan chess 0 Mar 28 13:39 test.sh\n[ssasidharan@lnx201 ~]$ chmod o+x test.sh\n[ssasidharan@lnx201 ~]$ ls -l test.sh\n-rwxr-xr-x 1 ssasidharan chess 0 Mar 28 13:39 test.sh\nYou can also combine u, g, o bits and r, w, x bits with + or -:\n[ssasidharan@lnx201 ~]$ chmod ugo-r test.sh\n[ssasidharan@lnx201 ~]$ ls -l test.sh\n--wx--x--x 1 ssasidharan chess 0 Mar 28 13:39 test.sh\nI just made the file unreadable by everyone, even me!\n[ssasidharan@lnx201 ~]$ cat test.sh\ncat: test.sh: Permission denied\nOf course you can restore the permission with chmod ugo+r test.sh\nNote that when invoking chmod, a (or all) is equivalent of ugo (user + group + others). You can also omit a or ugo if you want everyone to have the same permissions. So the below all are equivalent:\n[ssasidharan@lnx201 ~]$ chmod ugo+r test.sh\n[ssasidharan@lnx201 ~]$ chmod a+r test.sh\n[ssasidharan@lnx201 ~]$ chmod +r test.sh\n(If you want to change owner or group of a file/folder, you can do that with chown and chgrp. This probably is not immediately useful; it is enough to know that these commands exist.)"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#symbolic-links",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#symbolic-links",
    "title": "Linux, Commandline, and Scripting",
    "section": "Symbolic links",
    "text": "Symbolic links\nTODO"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#noteworthy-facts-about-file-names",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#noteworthy-facts-about-file-names",
    "title": "Linux, Commandline, and Scripting",
    "section": "Noteworthy facts about file names",
    "text": "Noteworthy facts about file names\n\nFile/folder names that begin with a . (period character) are “hidden”: meaning that they will not be listed in the output of ls command by default. You can list them with ls -a. They are also called dotfiles.\nConfiguration files for the programs you use (such as .bashrc for bash configuration) are often saved in hidden files. This way they usually stay out of your way without creating a clutter.\nFile/folder names and commands are case sensitive in Linux. Thus Notes.txt and notes.txt and NOTES.TXT are all distinct files.\nAs a matter of convenience, it is better to avoid spaces and special characters in file/folder names, as it will make tasks a little more difficult. If you need to represent spaces between words, you can replace spaces with _ (the underscore character)."
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#io-redirection",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#io-redirection",
    "title": "Linux, Commandline, and Scripting",
    "section": "I/O redirection",
    "text": "I/O redirection\nI/O redirection lets us to change where standard output gets printed. To redirect standard output, we use the &gt; operator.\n[ssasidharan@lnx201 ~]$ ls -l &gt; ls-output.txt\nAs a result of redirection, a new file named ls-output.txt will be created. You can view its contents using cat command.\n[ssasidharan@lnx201 ~]$ ls -l ls-output.txt\n-rw-r--r-- 1 ssasidharan chess 807 Apr  1 17:32 ls-output.txt\n[ssasidharan@lnx201 ~]$ cat ls-output.txt\ntotal 4\ndrwxr-xr-x 2 ssasidharan chess   28 Mar 28 09:36 bin\ndrwxr-xr-x 2 ssasidharan chess  144 Mar 12 00:27 CLASSE_shortcuts\ndrwxr-xr-x 2 ssasidharan chess   30 Mar 26 15:22 Desktop\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Documents\nlrwxrwxrwx 1 ssasidharan chess   31 Mar 26 15:21 Downloads -&gt; /cdat/tem/ssasidharan/Downloads\n-rw-r--r-- 1 ssasidharan chess 3254 Mar  7 15:55 helloworld.ipynb\n-rw-r--r-- 1 ssasidharan chess    0 Apr  1 17:32 ls-output.txt\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Music\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Pictures\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Public\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Templates\n-rwxr-xr-x 1 ssasidharan chess    0 Mar 28 13:39 test.sh\ndrwxr-xr-x 2 ssasidharan chess    6 Mar 26 15:21 Videos\nNote that if there already was a file named ls-output.txt, the redirection above would have overwritten its contents. You want to be careful about this.\nWhat if you want to discard stdout completely? You can redirect it to the special file /dev/null:\n[ssasidharan@lnx201 ~]$ ls -l &gt;&gt; ls-output.txt\nIf you want to append stdout to a file instead of overwriting it, you can use &gt;&gt; operator:\n[ssasidharan@lnx201 ~]$ ls -l &gt;&gt; ls-output.txt\nThe &lt; operator is a sort of inverse of the &gt; operator:\n[ssasidharan@lnx201 ~]$ echo \"Shall I compare thee to a summer’s day?\" &gt; sonnet18.txt\n[ssasidharan@lnx201 ~]$ cat sonnet18.txt\nShall I compare thee to a summer’s day?\n[ssasidharan@lnx201 ~]$ cat &lt; sonnet18.txt\nShall I compare thee to a summer’s day?\n(TODO: explain the above: echo and the different usage of cat.)"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#pipes",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#pipes",
    "title": "Linux, Commandline, and Scripting",
    "section": "Pipes",
    "text": "Pipes\nPrograms can write to standard output. Programs can also read from standard input. This means we can “chain” them together, such that one programs standard output is “piped” into another program’s standard input.\nThe operator to do this is | (vertical bar), also known as a pipe, and it is used in this manner: command1 | command2.\n[ssasidharan@lnx201 ~]$ ls -l /bin/ | less\nThe output of ls -l /bin is fairly large, so we pipe it into less, which allows you to scroll the output backward and forward, using up and down keyboard keys.\nYou can form longer pipes like this:\n[ssasidharan@lnx201 ~]$ ls /bin /usr/bin /sbin /usr/sbin | sort | uniq | wc\n   4289    4288   46820\n\nsort will sort lines of text files.\nuniq is used to filter adjacent matching lines the output of sort.\nwc is a word count program. It counts lines, words, and bytes present in its input."
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#listing-processes",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#listing-processes",
    "title": "Linux, Commandline, and Scripting",
    "section": "Listing processes",
    "text": "Listing processes\nYou can list running processes using ps command:\n[ssasidharan@lnx201 ~]$ ps\n    PID TTY          TIME CMD\n 694411 pts/81   00:00:00 ps\n3479688 pts/81   00:00:00 bash\nBy default, ps prints processes of the current user and terminal in four columns:\n\nPID is process id.\nTTY is the terminal associated with the process.\nTIME is the elapsed CPU time for the process.\nCMD is the command that created the process.\n\nUsually there are many more processes running in the system, and sometimes they were started by other users. You can list them, with more detail, by passing some options to ps:\n[ssasidharan@lnx201 ~]$ ps -ef | head\nUID          PID    PPID  C STIME TTY          TIME CMD\nroot           1       0  0 Jan10 ?        03:14:05 /usr/lib/systemd/systemd --switched-root --system --deserialize 22\nroot           2       0  0 Jan10 ?        00:01:12 [kthreadd]\nroot           6       2  0 Jan10 ?        00:12:16 [ksoftirqd/0]\nroot           7       2  0 Jan10 ?        00:01:10 [migration/0]\nroot           8       2  0 Jan10 ?        00:00:00 [rcu_bh]\nroot           9       2  0 Jan10 ?        11:14:26 [rcu_sched]\nroot          10       2  0 Jan10 ?        00:00:00 [lru-add-drain]\nroot          11       2  0 Jan10 ?        00:05:22 [watchdog/0]\nroot          12       2  0 Jan10 ?        00:00:24 [watchdog/1]\nRun man ps for details.\nPrograms like top and htop will list processes in friendlier, fancier format."
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#background-and-foreground-processes",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#background-and-foreground-processes",
    "title": "Linux, Commandline, and Scripting",
    "section": "Background and foreground processes",
    "text": "Background and foreground processes\nBy default, commands run in the foreground: they do their thing, use the terminal (to read input, print output), and finally exit. You need to wait for a foreground process to end before you start the next one, or use another terminal.\nWhen have a long-running process, you have the option of sending it to the background, using the & operator:\n[ssasidharan@lnx201 ~]$ sleep 100 &\n[1] 949751\nYou can use Control + Z to stop a foreground process and send it to the background:\n[ssasidharan@lnx201 ~]$ sleep 100\n^Z\n[1]+  Stopped                 sleep 100\nYou can list background processes using jobs command:\n[ssasidharan@lnx201 ~]$ jobs\n[1]-  Running                 sleep 100 &\n[2]+  Stopped                 sleep 100\nYou can bring a background process to foreground using fg command, and you can terminate it using Control + C:\n[ssasidharan@lnx201 ~]$ fg 2\nsleep 100\n^C\n[ssasidharan@lnx201 ~]$\nYou can use bg command to resume a stopped background process:\n[ssasidharan@lnx201 ~]$ sleep 100 &\n[1] 1746205\n[ssasidharan@lnx201 ~]$ sleep 100\n^Z\n[2]+  Stopped                 sleep 100\n[ssasidharan@lnx201 ~]$ jobs\n[1]-  Running                 sleep 100 &\n[2]+  Stopped                 sleep 100\n[ssasidharan@lnx201 ~]$ bg %2\n[2]+ sleep 100 &"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#terminating-processes",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#terminating-processes",
    "title": "Linux, Commandline, and Scripting",
    "section": "Terminating processes",
    "text": "Terminating processes\nSometimes you might want to terminate a program, perhaps because it is using too much CPU or memory. You can find out the offending program’s ID using ps or top or htop, and then you can use kill command to end the process.\nBy default, kill sends a signal called SIGTERM (more on signals later). If SIGTERM is unable to terminate the process (such as when the program is ignoring SIGTERM), you can try SIGKILL:\n[ssasidharan@lnx201 ~]$ ps\n    PID TTY          TIME CMD\n 796679 pts/116  00:00:00 bash\n1185454 pts/116  00:00:00 ps\n1748299 pts/116  00:00:00 sleep\n[ssasidharan@lnx201 ~]$ kill 1748299\n[ssasidharan@lnx201 ~]$ ps\n    PID TTY          TIME CMD\n 796679 pts/116  00:00:00 bash\n1203470 pts/116  00:00:00 ps\n1748299 pts/116  00:00:00 sleep\n[ssasidharan@lnx201 ~]$ kill -SIGKILL 1748299\n[2]+  Killed                  sleep 100\nYou can use killall command to kill processes by name:\n[ssasidharan@lnx201 ~]$ killall sleep\nsleep(1469283): Operation not permitted\nsleep(1509215): Operation not permitted\nsleep: no process found\nIn the above example, you are not running a sleep process, but some other users are, but you are not allowed to terminate them."
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#signals",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#signals",
    "title": "Linux, Commandline, and Scripting",
    "section": "Signals",
    "text": "Signals\nAs mentioned above, kill command sends signals to running processes, and we’ve already seen SIGTERM and SIGKILL. Signals are a process control mechanism. They are used to stop, resume, or terminate processes, and more.\nWhen we use Control + C or Control + Z, we are sending signals to process – SIGINT (or “keyboard interrupt”) and SIGTSTP (or “terminal stop”), respectively.\nSignals have numbers: SIGKILL is 9, so you can use kill -9 &lt;pid&gt; instead of kill -SIGKILL &lt;pid&gt;. You can also omit the SIG prefix, and use kill -KILL &lt;pid&gt;.\nHere are some common signals:\n\n       Signal     Value     Action   Comment\n       ──────────────────────────────────────────────────────────────────────\n       SIGHUP        1       Term    Hangup detected on controlling terminal\n                                     or death of controlling process\n       SIGINT        2       Term    Interrupt from keyboard\n       SIGQUIT       3       Core    Quit from keyboard\n       SIGILL        4       Core    Illegal Instruction\n       SIGABRT       6       Core    Abort signal from abort(3)\n       SIGFPE        8       Core    Floating point exception\n       SIGKILL       9       Term    Kill signal\n       SIGSEGV      11       Core    Invalid memory reference\n       SIGPIPE      13       Term    Broken pipe: write to pipe with no\n                                     readers\n       SIGALRM      14       Term    Timer signal from alarm(2)\n       SIGTERM      15       Term    Termination signal\nRun the command man 7 signal to read signal command’s manual page."
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#a-cheat-sheet",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#a-cheat-sheet",
    "title": "Linux, Commandline, and Scripting",
    "section": "A cheat sheet",
    "text": "A cheat sheet\n\n\n\nCommand\nDescription\n\n\n\n\necho\n\n\n\ncat\n\n\n\nhead\n\n\n\ntail\n\n\n\nmore\n\n\n\nless\n\n\n\n\n\n\n\nls\n\n\n\nmkdir\n\n\n\ncd\n\n\n\ncp\n\n\n\nrm\n\n\n\n\n\n\n\n\n\n\n\nsed\n\n\n\nawk\n\n\n\ngrep\n\n\n\nsleep\n\n\n\n\n\n\n\ntree\n\n\n\nfind\n\n\n\n\n\n\n\ndu\n\n\n\n\n\n\n\ngzip\n\n\n\ntar\n\n\n\n\n\n\n\nps\n\n\n\ntop\n\n\n\nhtop\n\n\n\nkill\n\n\n\nkillall\n\n\n\n\n\n\n\nping\n\n\n\nnetstat\n\n\n\n\n\n\n\nifconfig\n\n\n\nip\n\n\n\n\n\n\n\nhostname\n\n\n\nuname\n\n\n\n\n\n\n\ndate\n\n\n\ncal\n\n\n\n\n\n\n\nclear\n\n\n\nhistory\n\n\n\n\n\n\n\nssh\n\n\n\nscp\n\n\n\nsftp\n\n\n\nftp\n\n\n\nwget\n\n\n\ncurl"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#shell-builtins",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#shell-builtins",
    "title": "Linux, Commandline, and Scripting",
    "section": "Shell builtins",
    "text": "Shell builtins\n\ntype\nwhich"
  },
  {
    "objectID": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#aliases",
    "href": "theme-2-systems-fundamentals/sf-100-linux-commandline-scripting/sf100-linux-commandline-scripting.html#aliases",
    "title": "Linux, Commandline, and Scripting",
    "section": "Aliases",
    "text": "Aliases"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "X-CITE course materials",
    "section": "",
    "text": "X-CITE course is geared toward the community of scientists and researchers using the CHESS synchrotron X-ray facility and similar light sources.\nThis is the course outline:"
  },
  {
    "objectID": "index.html#theme-1-programming-fundamentals",
    "href": "index.html#theme-1-programming-fundamentals",
    "title": "X-CITE course materials",
    "section": "Theme 1: Programming Fundamentals",
    "text": "Theme 1: Programming Fundamentals\n\nPE 100: Python Programming and Jupyter notebooks\nPE 101: Using Python packages & libraries, Conda\nPE 102: Numerical data analysis with Python\nPE 103: Software version control, testing and debugging"
  },
  {
    "objectID": "index.html#theme-2-systems-fundamentals",
    "href": "index.html#theme-2-systems-fundamentals",
    "title": "X-CITE course materials",
    "section": "Theme 2: Systems Fundamentals",
    "text": "Theme 2: Systems Fundamentals\n\nSF 100: Intro to Linux, commandline, and scripting\nSF 101: Containers and virtualization\nSF 200: Parallel computing concepts\nSF 201: Batch Systems and compute farms with CHESS example"
  },
  {
    "objectID": "index.html#theme-3-distributed-computing-and-the-ci-ecosystem",
    "href": "index.html#theme-3-distributed-computing-and-the-ci-ecosystem",
    "title": "X-CITE course materials",
    "section": "Theme 3: Distributed Computing and the CI Ecosystem",
    "text": "Theme 3: Distributed Computing and the CI Ecosystem\n\nDC 100: Distributed computing concepts\nDC 101: Scientific Workflow management\nDC 102: Using science gateways with Open OnDemand example\nDC 200: Computing with CI ecosystem - ACCESS, PATh, Campus, Cloud"
  },
  {
    "objectID": "index.html#theme-4-x-ray-science-se-software",
    "href": "index.html#theme-4-x-ray-science-se-software",
    "title": "X-CITE course materials",
    "section": "Theme 4: X-Ray Science S&E Software",
    "text": "Theme 4: X-Ray Science S&E Software\n\nXS 100: Data collection, preparing input parameters, SPEC and CLI\nXS 101: Basic / on-the-fly data analysis, viewing detector images\nXS 102: Large-scale data analysis: from images to science parameters to interpretation\nXS 200: Metadata for data fidelity and systematic checks"
  },
  {
    "objectID": "index.html#theme-5-data-curation-and-fair",
    "href": "index.html#theme-5-data-curation-and-fair",
    "title": "X-CITE course materials",
    "section": "Theme 5: Data Curation and FAIR",
    "text": "Theme 5: Data Curation and FAIR\n\nCF 100: Intro to domain metadata standards, formats and repositories\nCF 101: Best practices for developing DMP\nCF 102: Metadata annotation and DOI\nCF 200: Curating data, code, workflows, and publishing\n\n\n\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html",
    "title": "Version control",
    "section": "",
    "text": "Version control systems are software tools that are used to track changes to source code or other collections of files.\nSome well-known version control systems include: Git, Mercurial, Subversion, Darcs, Fossil, CVS, and several proprietary systems. Each of them vary in practical usage and in implementation details.\nToday Git is the most popular one, and seem to have “won”, so Git is what we will be discussing here.\n\n\n\nWhen you work on a project, you often will want to save the state of your code at various points, such that you can go back and forth between these various points. When you work on a project as part of a team, you will also want to know who wrote some part of the code, when, and why.\nWhether you work alone or in a team, using a version control system will help you achieve the above goals.\nIn the absence of a version control system, you will often will end up with a chaotic mess which achieves the above goals in a poorer manner. You will likely resort to several almost-same-but-not-quite files variously named like so:\n\nnotebook.ipynb\nnotebook-2024-05-01.ipynb\nnotebook-working.ipynb\nnotebook-test.ipynb\n\nThis scheme is basically a messy reinvention of a version control system. That might work in the simple cases, but it will soon break down as you do more work on your project.\nInstead, what you want to do is learn to use a version control system properly. You want to avoid the cognitive overload of dealing with messy schemes based on filenames.\n\n\n\nAs stated above, Git is the most popular version control system in use today. Git is a command-line program that runs on all popular operating systems. If you use macOS or Linux, you probably have Git installed already.\nHere we assume that you are using the shell account that you have with CLASSE.\n$ git --help\n\n\n\n\n\ncommits\nstaging area\nremotes\nbranches\n\n\n\n\n\n\n\n$ ssh-keygen -t rsa -b 4096 -C \"you@example.com\"\n\n\n\n\n\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"you@example.com\n\n\n\n\n\n$ git init\n$ git add\n$ git commit\n$ git log\n$ git diff\n$ git merge\n$ git status\n$ git branch\n$ git clone\n$ git fetch\n$ git pull\n$ git push\n\n\n\nGitHub.com is what is known as a software “forge”: it is a Git hosting service that can host your source code, and provide additional services (such as bug tracking, code reviews, continuous integration, etc) that helps you collaborate with other people.\n\n\n\nWhile GitHub happens to be the most popular software forge, many others exist too:\n\nGitlab.com\nBitBucket.com\nCodeberg.org\n\nSome people prefer to self-host a forge, and some people prefer no forge at all. Since Git is a /distributed/ version control system, and you should be able to collaborate with no forge at all: you can share your changes as email attachments, if you want.\n\n\n\n\nCreate an account on GitHub.com, if you do not have an account there already.\nCreate a new repository on GitHub.com. Push some code that you are working on to that repository. If your project is not under version control, you will want to do that now.\nAdd some changes to the code. Commit the code. Push those commits also to the Git repository.\nCreate a “tag” (based on today’s date, or a version number), and push the tag to your repository."
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#what-is-it",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#what-is-it",
    "title": "Version control",
    "section": "",
    "text": "Version control systems are software tools that are used to track changes to source code or other collections of files.\nSome well-known version control systems include: Git, Mercurial, Subversion, Darcs, Fossil, CVS, and several proprietary systems. Each of them vary in practical usage and in implementation details.\nToday Git is the most popular one, and seem to have “won”, so Git is what we will be discussing here."
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#why-do-we-need-it",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#why-do-we-need-it",
    "title": "Version control",
    "section": "",
    "text": "When you work on a project, you often will want to save the state of your code at various points, such that you can go back and forth between these various points. When you work on a project as part of a team, you will also want to know who wrote some part of the code, when, and why.\nWhether you work alone or in a team, using a version control system will help you achieve the above goals.\nIn the absence of a version control system, you will often will end up with a chaotic mess which achieves the above goals in a poorer manner. You will likely resort to several almost-same-but-not-quite files variously named like so:\n\nnotebook.ipynb\nnotebook-2024-05-01.ipynb\nnotebook-working.ipynb\nnotebook-test.ipynb\n\nThis scheme is basically a messy reinvention of a version control system. That might work in the simple cases, but it will soon break down as you do more work on your project.\nInstead, what you want to do is learn to use a version control system properly. You want to avoid the cognitive overload of dealing with messy schemes based on filenames."
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#version-control-in-practice-git",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#version-control-in-practice-git",
    "title": "Version control",
    "section": "",
    "text": "As stated above, Git is the most popular version control system in use today. Git is a command-line program that runs on all popular operating systems. If you use macOS or Linux, you probably have Git installed already.\nHere we assume that you are using the shell account that you have with CLASSE.\n$ git --help"
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#git-concepts",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#git-concepts",
    "title": "Version control",
    "section": "",
    "text": "commits\nstaging area\nremotes\nbranches"
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#getting-started-with-git",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#getting-started-with-git",
    "title": "Version control",
    "section": "",
    "text": "$ ssh-keygen -t rsa -b 4096 -C \"you@example.com\"\n\n\n\n\n\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"you@example.com"
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#git-subcommands",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#git-subcommands",
    "title": "Version control",
    "section": "",
    "text": "$ git init\n$ git add\n$ git commit\n$ git log\n$ git diff\n$ git merge\n$ git status\n$ git branch\n$ git clone\n$ git fetch\n$ git pull\n$ git push"
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#github",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#github",
    "title": "Version control",
    "section": "",
    "text": "GitHub.com is what is known as a software “forge”: it is a Git hosting service that can host your source code, and provide additional services (such as bug tracking, code reviews, continuous integration, etc) that helps you collaborate with other people."
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#alternatives-to-github",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#alternatives-to-github",
    "title": "Version control",
    "section": "",
    "text": "While GitHub happens to be the most popular software forge, many others exist too:\n\nGitlab.com\nBitBucket.com\nCodeberg.org\n\nSome people prefer to self-host a forge, and some people prefer no forge at all. Since Git is a /distributed/ version control system, and you should be able to collaborate with no forge at all: you can share your changes as email attachments, if you want."
  },
  {
    "objectID": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#exercises",
    "href": "theme-1-prog-fundamentals/pe-103-vcs-testing-debugging/01-vcs.html#exercises",
    "title": "Version control",
    "section": "",
    "text": "Create an account on GitHub.com, if you do not have an account there already.\nCreate a new repository on GitHub.com. Push some code that you are working on to that repository. If your project is not under version control, you will want to do that now.\nAdd some changes to the code. Commit the code. Push those commits also to the Git repository.\nCreate a “tag” (based on today’s date, or a version number), and push the tag to your repository."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This website hosts material meant for CyberInfrastructure Training and Education for Synchrotron X-Ray Science (X-CITE) course."
  }
]